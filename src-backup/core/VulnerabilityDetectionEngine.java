package ai.intelliswarm.vulnpatcher.core;

import ai.intelliswarm.vulnpatcher.git.GitRepositoryScanner;
import ai.intelliswarm.vulnpatcher.models.ScanResult;
import ai.intelliswarm.vulnpatcher.models.Vulnerability;
import ai.intelliswarm.vulnpatcher.vulnerabilities.VulnerabilityDatabaseService;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@ApplicationScoped
public class VulnerabilityDetectionEngine {
    
    private static final Logger LOGGER = Logger.getLogger(VulnerabilityDetectionEngine.class.getName());
    
    @Inject
    VulnerabilityDatabaseService vulnerabilityDatabase;
    
    @Inject
    ContextManager contextManager;
    
    // Vulnerability pattern matchers
    private final Map<String, VulnerabilityMatcher> matchers = new ConcurrentHashMap<>();
    
    public VulnerabilityDetectionEngine() {
        initializeMatchers();
    }
    
    private void initializeMatchers() {
        // Dependency version matcher
        matchers.put("DEPENDENCY_VERSION", new DependencyVersionMatcher());
        
        // Code pattern matchers
        matchers.put("SQL_INJECTION", new SqlInjectionMatcher());
        matchers.put("XSS", new XssMatcher());
        matchers.put("PATH_TRAVERSAL", new PathTraversalMatcher());
        matchers.put("INSECURE_CRYPTO", new InsecureCryptoMatcher());
        matchers.put("HARDCODED_SECRETS", new HardcodedSecretsMatcher());
        matchers.put("INSECURE_DESERIALIZATION", new InsecureDeserializationMatcher());
        matchers.put("XXE", new XxeMatcher());
        matchers.put("COMMAND_INJECTION", new CommandInjectionMatcher());
    }
    
    public CompletableFuture<ScanResult> detectVulnerabilities(
            GitRepositoryScanner.ScanSession scanSession) {
        
        return CompletableFuture.supplyAsync(() -> {
            ScanResult result = new ScanResult();
            result.setScanId(scanSession.getSessionId());
            result.setRepositoryUrl(scanSession.getRepositoryUrl());
            result.setBranch(scanSession.getBranch());
            result.setScanStartTime(scanSession.getStartTime());
            result.setStatus(ScanResult.ScanStatus.IN_PROGRESS);
            
            try {
                List<ScanResult.VulnerabilityMatch> vulnerabilities = new ArrayList<>();
                
                // 1. Check dependencies for known vulnerabilities
                if (scanSession.getDependencies() != null) {
                    vulnerabilities.addAll(checkDependencyVulnerabilities(scanSession));
                }
                
                // 2. Analyze code patterns
                if (scanSession.getAnalysisResult() != null) {
                    vulnerabilities.addAll(analyzeCodePatterns(scanSession));
                }
                
                // 3. Use AI-powered semantic analysis
                vulnerabilities.addAll(performSemanticAnalysis(scanSession));
                
                // 4. Aggregate and deduplicate results
                List<ScanResult.VulnerabilityMatch> finalVulnerabilities = 
                    deduplicateAndPrioritize(vulnerabilities);
                
                result.setVulnerabilities(finalVulnerabilities);
                
                // Calculate statistics
                Map<String, Integer> countBySeverity = new HashMap<>();
                for (ScanResult.VulnerabilityMatch match : finalVulnerabilities) {
                    String severity = match.getVulnerability().getSeverity().name();
                    countBySeverity.merge(severity, 1, Integer::sum);
                }
                result.setVulnerabilityCountBySeverity(countBySeverity);
                
                result.setScanEndTime(scanSession.getEndTime());
                result.setStatus(ScanResult.ScanStatus.COMPLETED);
                
                LOGGER.info(String.format("Vulnerability detection completed. Found %d vulnerabilities", 
                    finalVulnerabilities.size()));
                
            } catch (Exception e) {
                LOGGER.severe("Error during vulnerability detection: " + e.getMessage());
                result.setStatus(ScanResult.ScanStatus.FAILED);
            }
            
            return result;
        });
    }
    
    private List<ScanResult.VulnerabilityMatch> checkDependencyVulnerabilities(
            GitRepositoryScanner.ScanSession scanSession) {
        
        List<ScanResult.VulnerabilityMatch> matches = new ArrayList<>();
        
        for (Map.Entry<String, List<GitRepositoryScanner.Dependency>> entry : 
                scanSession.getDependencies().getDependenciesByType().entrySet()) {
            
            String ecosystem = entry.getKey();
            List<GitRepositoryScanner.Dependency> dependencies = entry.getValue();
            
            for (GitRepositoryScanner.Dependency dep : dependencies) {
                // Search for vulnerabilities in the database
                VulnerabilityDatabaseService.VulnerabilitySearchCriteria criteria = 
                    new VulnerabilityDatabaseService.VulnerabilitySearchCriteria();
                criteria.setPackageName(dep.getName());
                criteria.setLanguage(mapEcosystemToLanguage(ecosystem));
                
                List<Vulnerability> vulns = vulnerabilityDatabase.search(criteria);
                
                for (Vulnerability vuln : vulns) {
                    if (isVersionAffected(dep.getVersion(), vuln)) {
                        ScanResult.VulnerabilityMatch match = new ScanResult.VulnerabilityMatch();
                        match.setVulnerability(vuln);
                        match.setFilePath(getDependencyFilePath(ecosystem, scanSession.getLocalPath()));
                        match.setMatchType(ScanResult.VulnerabilityMatch.MatchType.DEPENDENCY_VERSION);
                        match.setAffectedCode(String.format("%s:%s", dep.getName(), dep.getVersion()));
                        match.setSuggestedFix(generateDependencyFix(dep, vuln));
                        match.setConfidence(0.95); // High confidence for exact dependency matches
                        
                        Map<String, Object> context = new HashMap<>();
                        context.put("ecosystem", ecosystem);
                        context.put("currentVersion", dep.getVersion());
                        context.put("fixedVersions", vuln.getFixedVersions());
                        match.setContext(context);
                        
                        matches.add(match);
                    }
                }
            }
        }
        
        return matches;
    }
    
    private List<ScanResult.VulnerabilityMatch> analyzeCodePatterns(
            GitRepositoryScanner.ScanSession scanSession) {
        
        List<ScanResult.VulnerabilityMatch> matches = new ArrayList<>();
        StreamingCodeAnalyzer.StreamingScanResult analysisResult = scanSession.getAnalysisResult();
        
        for (StreamingCodeAnalyzer.FileAnalysisResult fileResult : analysisResult.getAnalyzedFiles()) {
            // Check against pattern matchers
            for (Map.Entry<String, VulnerabilityMatcher> entry : matchers.entrySet()) {
                String patternType = entry.getKey();
                VulnerabilityMatcher matcher = entry.getValue();
                
                if (matcher.isApplicable(fileResult.getFileType())) {
                    List<PatternMatch> patternMatches = matcher.findMatches(fileResult);
                    
                    for (PatternMatch pm : patternMatches) {
                        // Look for corresponding vulnerability in database
                        Vulnerability vuln = findOrCreateVulnerability(patternType, pm);
                        
                        ScanResult.VulnerabilityMatch match = new ScanResult.VulnerabilityMatch();
                        match.setVulnerability(vuln);
                        match.setFilePath(fileResult.getFilePath());
                        match.setLineNumber(pm.getLineNumber());
                        match.setMatchType(ScanResult.VulnerabilityMatch.MatchType.CODE_PATTERN);
                        match.setAffectedCode(pm.getCodeSnippet());
                        match.setSuggestedFix(matcher.generateFix(pm, fileResult));
                        match.setConfidence(pm.getConfidence());
                        
                        Map<String, Object> context = new HashMap<>();
                        context.put("patternType", patternType);
                        context.put("language", fileResult.getFileType());
                        match.setContext(context);
                        
                        matches.add(match);
                    }
                }
            }
        }
        
        return matches;
    }
    
    private List<ScanResult.VulnerabilityMatch> performSemanticAnalysis(
            GitRepositoryScanner.ScanSession scanSession) {
        
        List<ScanResult.VulnerabilityMatch> matches = new ArrayList<>();
        
        try {
            ContextManager.SessionContext sessionContext = 
                contextManager.getOrCreateSession(scanSession.getSessionId());
            
            // Define semantic vulnerability queries
            List<String> semanticQueries = Arrays.asList(
                "unsafe user input handling without validation",
                "database query construction with string concatenation",
                "file operations with user-controlled paths",
                "weak cryptographic algorithms or key management",
                "authentication bypass vulnerabilities",
                "race conditions in concurrent code",
                "buffer overflow risks in native code",
                "insecure random number generation",
                "missing security headers in HTTP responses",
                "cross-origin resource sharing misconfigurations"
            );
            
            for (String query : semanticQueries) {
                List<ContextManager.RelevantContext> relevantContexts = 
                    sessionContext.getRelevantContext(query, 5);
                
                for (ContextManager.RelevantContext context : relevantContexts) {
                    if (context.getRelevanceScore() > 0.7) { // High relevance threshold
                        // Create semantic vulnerability match
                        Vulnerability vuln = createSemanticVulnerability(query, context);
                        
                        ScanResult.VulnerabilityMatch match = new ScanResult.VulnerabilityMatch();
                        match.setVulnerability(vuln);
                        match.setFilePath(context.getFilePath());
                        match.setLineNumber(context.getStartLine());
                        match.setMatchType(ScanResult.VulnerabilityMatch.MatchType.CODE_PATTERN);
                        match.setAffectedCode(context.getContent());
                        match.setConfidence(context.getRelevanceScore());
                        
                        Map<String, Object> contextMap = new HashMap<>();
                        contextMap.put("semanticQuery", query);
                        contextMap.put("relevanceScore", context.getRelevanceScore());
                        match.setContext(contextMap);
                        
                        matches.add(match);
                    }
                }
            }
            
        } catch (Exception e) {
            LOGGER.warning("Error during semantic analysis: " + e.getMessage());
        }
        
        return matches;
    }
    
    private List<ScanResult.VulnerabilityMatch> deduplicateAndPrioritize(
            List<ScanResult.VulnerabilityMatch> vulnerabilities) {
        
        // Group by file and vulnerability type
        Map<String, List<ScanResult.VulnerabilityMatch>> grouped = 
            vulnerabilities.stream().collect(Collectors.groupingBy(
                match -> match.getFilePath() + ":" + match.getVulnerability().getId()
            ));
        
        // Keep highest confidence match for each group
        List<ScanResult.VulnerabilityMatch> deduplicated = new ArrayList<>();
        for (List<ScanResult.VulnerabilityMatch> group : grouped.values()) {
            ScanResult.VulnerabilityMatch best = group.stream()
                .max(Comparator.comparing(ScanResult.VulnerabilityMatch::getConfidence))
                .orElse(group.get(0));
            deduplicated.add(best);
        }
        
        // Sort by severity and confidence
        deduplicated.sort((a, b) -> {
            int severityCompare = a.getVulnerability().getSeverity().compareTo(
                b.getVulnerability().getSeverity()
            );
            if (severityCompare != 0) return severityCompare;
            return Double.compare(b.getConfidence(), a.getConfidence());
        });
        
        return deduplicated;
    }
    
    private boolean isVersionAffected(String currentVersion, Vulnerability vuln) {
        if (currentVersion == null || vuln.getAffectedVersions() == null) {
            return false;
        }
        
        // Simple version checking - in production use proper version comparison library
        for (String affectedVersion : vuln.getAffectedVersions()) {
            if (affectedVersion.contains("*") || affectedVersion.equals(currentVersion)) {
                return true;
            }
            
            // Check version ranges
            if (affectedVersion.contains("<")) {
                // Simplified - use proper version comparison
                return true;
            }
        }
        
        return false;
    }
    
    private String generateDependencyFix(GitRepositoryScanner.Dependency dep, Vulnerability vuln) {
        if (vuln.getFixedVersions() != null && !vuln.getFixedVersions().isEmpty()) {
            String fixedVersion = vuln.getFixedVersions().get(0);
            return String.format("Update %s from %s to %s", dep.getName(), dep.getVersion(), fixedVersion);
        }
        return "No fixed version available. Consider removing or replacing this dependency.";
    }
    
    private String getDependencyFilePath(String ecosystem, String repoPath) {
        Map<String, String> ecosystemFiles = Map.of(
            "maven", "pom.xml",
            "npm", "package.json",
            "python", "requirements.txt",
            "gradle", "build.gradle",
            "ruby", "Gemfile"
        );
        
        String fileName = ecosystemFiles.getOrDefault(ecosystem, "dependencies");
        return Paths.get(repoPath, fileName).toString();
    }
    
    private String mapEcosystemToLanguage(String ecosystem) {
        Map<String, String> ecosystemMap = Map.of(
            "maven", "java",
            "gradle", "java",
            "npm", "javascript",
            "pip", "python",
            "gem", "ruby"
        );
        
        return ecosystemMap.getOrDefault(ecosystem, ecosystem);
    }
    
    private Vulnerability findOrCreateVulnerability(String patternType, PatternMatch match) {
        // Check if vulnerability exists in database
        VulnerabilityDatabaseService.VulnerabilitySearchCriteria criteria = 
            new VulnerabilityDatabaseService.VulnerabilitySearchCriteria();
        criteria.setSearchText(patternType);
        
        List<Vulnerability> existing = vulnerabilityDatabase.search(criteria);
        if (!existing.isEmpty()) {
            return existing.get(0);
        }
        
        // Create new vulnerability for the pattern
        Vulnerability vuln = new Vulnerability();
        vuln.setId("PATTERN-" + patternType + "-" + UUID.randomUUID().toString().substring(0, 8));
        vuln.setSource("INTERNAL");
        vuln.setTitle(patternType.replace("_", " ") + " Vulnerability");
        vuln.setDescription(getPatternDescription(patternType));
        vuln.setSeverity(getPatternSeverity(patternType));
        vuln.setPublishedDate(LocalDateTime.now());
        vuln.setLastModifiedDate(LocalDateTime.now());
        
        return vuln;
    }
    
    private Vulnerability createSemanticVulnerability(String query, ContextManager.RelevantContext context) {
        Vulnerability vuln = new Vulnerability();
        vuln.setId("SEMANTIC-" + UUID.randomUUID().toString().substring(0, 8));
        vuln.setSource("AI_ANALYSIS");
        vuln.setTitle("Potential Security Issue: " + query);
        vuln.setDescription("AI-detected potential vulnerability based on semantic analysis of code patterns");
        vuln.setSeverity(Vulnerability.Severity.MEDIUM); // Default to medium for AI-detected
        vuln.setPublishedDate(LocalDateTime.now());
        vuln.setLastModifiedDate(LocalDateTime.now());
        
        return vuln;
    }
    
    private String getPatternDescription(String patternType) {
        Map<String, String> descriptions = Map.of(
            "SQL_INJECTION", "SQL injection vulnerability allows attackers to execute arbitrary SQL commands",
            "XSS", "Cross-site scripting vulnerability allows injection of malicious scripts",
            "PATH_TRAVERSAL", "Path traversal vulnerability allows access to files outside intended directory",
            "INSECURE_CRYPTO", "Use of weak or broken cryptographic algorithms",
            "HARDCODED_SECRETS", "Hardcoded secrets or credentials in source code"
        );
        
        return descriptions.getOrDefault(patternType, "Security vulnerability detected by pattern matching");
    }
    
    private Vulnerability.Severity getPatternSeverity(String patternType) {
        Map<String, Vulnerability.Severity> severities = Map.of(
            "SQL_INJECTION", Vulnerability.Severity.CRITICAL,
            "XSS", Vulnerability.Severity.HIGH,
            "PATH_TRAVERSAL", Vulnerability.Severity.HIGH,
            "INSECURE_CRYPTO", Vulnerability.Severity.HIGH,
            "HARDCODED_SECRETS", Vulnerability.Severity.CRITICAL
        );
        
        return severities.getOrDefault(patternType, Vulnerability.Severity.MEDIUM);
    }
    
    // Pattern matching interfaces and implementations
    private interface VulnerabilityMatcher {
        boolean isApplicable(String fileType);
        List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file);
        String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file);
    }
    
    private static class PatternMatch {
        private int lineNumber;
        private String codeSnippet;
        private double confidence;
        private Map<String, Object> metadata;
        
        // Getters and setters
        public int getLineNumber() { return lineNumber; }
        public void setLineNumber(int lineNumber) { this.lineNumber = lineNumber; }
        public String getCodeSnippet() { return codeSnippet; }
        public void setCodeSnippet(String codeSnippet) { this.codeSnippet = codeSnippet; }
        public double getConfidence() { return confidence; }
        public void setConfidence(double confidence) { this.confidence = confidence; }
        public Map<String, Object> getMetadata() { return metadata; }
        public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    }
    
    // Example matcher implementations
    private class DependencyVersionMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return Arrays.asList("pom.xml", "package.json", "requirements.txt", "build.gradle")
                .contains(fileType);
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            // This is handled separately in checkDependencyVulnerabilities
            return Collections.emptyList();
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Update to latest secure version";
        }
    }
    
    private class SqlInjectionMatcher implements VulnerabilityMatcher {
        private final Pattern[] patterns = {
            Pattern.compile(".*\\+.*(?:request\\.getParameter|params\\[|input).*", Pattern.CASE_INSENSITIVE),
            Pattern.compile(".*String\\s+query\\s*=.*\\+.*", Pattern.CASE_INSENSITIVE),
            Pattern.compile(".*executeQuery\\s*\\(.*\\+.*\\)", Pattern.CASE_INSENSITIVE)
        };
        
        @Override
        public boolean isApplicable(String fileType) {
            return Arrays.asList("java", "javascript", "python", "php", "csharp").contains(fileType);
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            List<PatternMatch> matches = new ArrayList<>();
            
            for (StreamingCodeAnalyzer.PotentialVulnerability vuln : file.getPotentialVulnerabilities()) {
                if ("SQL_INJECTION".equals(vuln.getCategory())) {
                    PatternMatch match = new PatternMatch();
                    match.setLineNumber(vuln.getLineNumber());
                    match.setCodeSnippet(vuln.getCodeSnippet());
                    match.setConfidence(vuln.getConfidence());
                    matches.add(match);
                }
            }
            
            return matches;
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Use parameterized queries or prepared statements instead of string concatenation";
        }
    }
    
    // Additional matchers would be implemented similarly...
    private class XssMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return Arrays.asList("java", "javascript", "typescript", "jsx", "tsx", "php").contains(fileType);
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            return new ArrayList<>(); // Implementation needed
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Encode user input before rendering in HTML context";
        }
    }
    
    private class PathTraversalMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return true; // Applicable to all languages
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            return new ArrayList<>(); // Implementation needed
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Validate and sanitize file paths, use a whitelist approach";
        }
    }
    
    private class InsecureCryptoMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return true;
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            List<PatternMatch> matches = new ArrayList<>();
            
            for (StreamingCodeAnalyzer.PotentialVulnerability vuln : file.getPotentialVulnerabilities()) {
                if ("WEAK_CRYPTO".equals(vuln.getCategory())) {
                    PatternMatch match = new PatternMatch();
                    match.setLineNumber(vuln.getLineNumber());
                    match.setCodeSnippet(vuln.getCodeSnippet());
                    match.setConfidence(vuln.getConfidence());
                    matches.add(match);
                }
            }
            
            return matches;
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Use strong cryptographic algorithms (AES-256, RSA-2048+, SHA-256+)";
        }
    }
    
    private class HardcodedSecretsMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return true;
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            List<PatternMatch> matches = new ArrayList<>();
            
            for (StreamingCodeAnalyzer.PotentialVulnerability vuln : file.getPotentialVulnerabilities()) {
                if ("HARDCODED_SECRET".equals(vuln.getCategory())) {
                    PatternMatch match = new PatternMatch();
                    match.setLineNumber(vuln.getLineNumber());
                    match.setCodeSnippet(vuln.getCodeSnippet());
                    match.setConfidence(vuln.getConfidence());
                    matches.add(match);
                }
            }
            
            return matches;
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Use environment variables or secure credential management systems";
        }
    }
    
    private class InsecureDeserializationMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return Arrays.asList("java", "python", "csharp", "php").contains(fileType);
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            return new ArrayList<>(); // Implementation needed
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Validate and sanitize serialized data, use safe deserialization methods";
        }
    }
    
    private class XxeMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return Arrays.asList("java", "csharp", "python").contains(fileType);
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            return new ArrayList<>(); // Implementation needed
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Disable external entity processing in XML parsers";
        }
    }
    
    private class CommandInjectionMatcher implements VulnerabilityMatcher {
        @Override
        public boolean isApplicable(String fileType) {
            return true;
        }
        
        @Override
        public List<PatternMatch> findMatches(StreamingCodeAnalyzer.FileAnalysisResult file) {
            return new ArrayList<>(); // Implementation needed
        }
        
        @Override
        public String generateFix(PatternMatch match, StreamingCodeAnalyzer.FileAnalysisResult file) {
            return "Use parameterized commands or proper input validation";
        }
    }
}