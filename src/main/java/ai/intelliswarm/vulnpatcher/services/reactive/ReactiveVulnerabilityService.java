package ai.intelliswarm.vulnpatcher.services.reactive;

import ai.intelliswarm.vulnpatcher.config.MetricsConfig;
import ai.intelliswarm.vulnpatcher.models.Vulnerability;
import ai.intelliswarm.vulnpatcher.sources.VulnerabilitySource;
import io.smallrye.mutiny.Multi;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Instance;
import jakarta.inject.Inject;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@ApplicationScoped
public class ReactiveVulnerabilityService {
    
    @Inject
    Instance<VulnerabilitySource> vulnerabilitySources;
    
    @Inject
    MetricsConfig.MetricsService metricsService;
    
    private static final int BATCH_SIZE = 100;
    private static final Duration TIMEOUT = Duration.ofMinutes(10);
    
    public Multi<Vulnerability> fetchVulnerabilitiesStream() {
        return Multi.createFrom().iterable(getEnabledSources())
            .onItem().transformToMultiAndMerge(this::fetchFromSource)
            .onItem().invoke(vuln -> metricsService.incrementVulnerabilitiesDetected());
    }
    
    public Multi<Vulnerability> fetchVulnerabilitiesBySeverity(String severity) {
        return fetchVulnerabilitiesStream()
            .filter(vuln -> severity.equals(vuln.getSeverity()));
    }
    
    public Multi<Vulnerability> fetchVulnerabilitiesForLanguages(List<String> languages) {
        return fetchVulnerabilitiesStream()
            .filter(vuln -> vuln.getAffectedLanguages() != null && 
                !Collections.disjoint(vuln.getAffectedLanguages(), languages));
    }
    
    public Multi<List<Vulnerability>> fetchVulnerabilitiesInBatches() {
        return fetchVulnerabilitiesStream()
            .group().intoLists().of(BATCH_SIZE);
    }
    
    public Multi<Vulnerability> searchVulnerabilities(String keyword) {
        return fetchVulnerabilitiesStream()
            .filter(vuln -> 
                (vuln.getId() != null && vuln.getId().contains(keyword)) ||
                (vuln.getTitle() != null && vuln.getTitle().contains(keyword)) ||
                (vuln.getDescription() != null && vuln.getDescription().contains(keyword))
            );
    }
    
    public Uni<List<Vulnerability>> fetchAllVulnerabilities() {
        return fetchVulnerabilitiesStream()
            .collect().asList()
            .ifNoItem().after(TIMEOUT).fail();
    }
    
    public Uni<VulnerabilityStats> getVulnerabilityStats() {
        return fetchVulnerabilitiesStream()
            .collect().asList()
            .map(vulns -> {
                VulnerabilityStats stats = new VulnerabilityStats();
                stats.total = vulns.size();
                
                for (Vulnerability vuln : vulns) {
                    switch (vuln.getSeverity()) {
                        case "CRITICAL" -> stats.critical++;
                        case "HIGH" -> stats.high++;
                        case "MEDIUM" -> stats.medium++;
                        case "LOW" -> stats.low++;
                    }
                }
                
                return stats;
            });
    }
    
    private Multi<Vulnerability> fetchFromSource(VulnerabilitySource source) {
        long startTime = System.currentTimeMillis();
        
        return source.fetchVulnerabilities()
            .onItem().transformToMulti(Multi.createFrom()::iterable)
            .onTermination().invoke(() -> {
                long duration = System.currentTimeMillis() - startTime;
                metricsService.recordApiCallDuration(source.getSourceName(), duration);
            })
            .onFailure().invoke(throwable -> 
                metricsService.incrementApiCallErrors(source.getSourceName())
            )
            .onFailure().recoverWithMulti(Multi.createFrom().empty());
    }
    
    private List<VulnerabilitySource> getEnabledSources() {
        return vulnerabilitySources.stream()
            .filter(VulnerabilitySource::isEnabled)
            .collect(Collectors.toList());
    }
    
    public static class VulnerabilityStats {
        public int total;
        public int critical;
        public int high;
        public int medium;
        public int low;
        
        public double getCriticalPercentage() {
            return total > 0 ? (critical * 100.0) / total : 0.0;
        }
        
        public double getHighPercentage() {
            return total > 0 ? (high * 100.0) / total : 0.0;
        }
        
        public double getMediumPercentage() {
            return total > 0 ? (medium * 100.0) / total : 0.0;
        }
        
        public double getLowPercentage() {
            return total > 0 ? (low * 100.0) / total : 0.0;
        }
    }
}