package ai.intelliswarm.vulnpatcher.sources;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.TestProfile;
import io.smallrye.mutiny.Uni;
import jakarta.inject.Inject;
import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import ai.intelliswarm.vulnpatcher.models.Vulnerability;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests to verify actual vulnerability database downloads.
 * These tests connect to real vulnerability sources and verify data retrieval.
 */
@QuarkusTest
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class VulnerabilitySourcesIntegrationTest {
    
    @Inject
    jakarta.enterprise.inject.Instance<VulnerabilitySource> vulnerabilitySourcesInstance;
    
    private List<VulnerabilitySource> vulnerabilitySources;
    
    @Inject
    CVESource cveSource;
    
    @Inject
    GHSASource ghsaSource;
    
    @Inject
    OSVSource osvSource;
    
    @Inject
    SnykSource snykSource;
    
    @Inject
    OSSIndexSource ossIndexSource;
    
    @Inject
    OVALSource ovalSource;
    
    private static final Duration TIMEOUT = Duration.ofMinutes(5);
    
    @BeforeAll
    void setupIntegrationTests() {
        // Convert Instance to List
        vulnerabilitySources = new ArrayList<>();
        vulnerabilitySourcesInstance.forEach(vulnerabilitySources::add);
        
        System.out.println("Starting vulnerability sources integration tests");
        System.out.println("Available sources: " + vulnerabilitySources.size());
        vulnerabilitySources.forEach(source -> 
            System.out.println("- " + source.getSourceName() + " (enabled: " + source.isEnabled() + ")")
        );
    }
    
    @Test
    @Order(1)
    @DisplayName("Should have all vulnerability sources registered")
    void testAllSourcesRegistered() {
        assertNotNull(vulnerabilitySources);
        assertFalse(vulnerabilitySources.isEmpty());
        
        List<String> sourceNames = vulnerabilitySources.stream()
            .map(VulnerabilitySource::getSourceName)
            .collect(Collectors.toList());
        
        assertTrue(sourceNames.contains("CVE"), "CVE source should be registered");
        assertTrue(sourceNames.contains("GHSA"), "GHSA source should be registered");
        assertTrue(sourceNames.contains("OSV"), "OSV source should be registered");
        assertTrue(sourceNames.contains("Snyk"), "Snyk source should be registered");
        assertTrue(sourceNames.contains("OSSIndex"), "OSSIndex source should be registered");
        assertTrue(sourceNames.contains("OVAL"), "OVAL source should be registered");
    }
    
    @Test
    @Order(2)
    @DisplayName("CVE source should download vulnerabilities from NVD")
    @Timeout(value = 5, unit = TimeUnit.MINUTES)
    void testCVESourceDownload() {
        if (!cveSource.isEnabled()) {
            System.out.println("CVE source is disabled, skipping test");
            return;
        }
        
        List<Vulnerability> vulnerabilities = cveSource.fetchVulnerabilities()
            .await().atMost(TIMEOUT);
        
        assertNotNull(vulnerabilities);
        assertFalse(vulnerabilities.isEmpty(), "CVE source should return vulnerabilities");
        
        // Verify CVE data structure
        Vulnerability firstVuln = vulnerabilities.get(0);
        assertNotNull(firstVuln.getId(), "CVE ID should not be null");
        assertTrue(firstVuln.getId().startsWith("CVE-"), "CVE ID should start with CVE-");
        assertNotNull(firstVuln.getTitle(), "CVE title should not be null");
        assertNotNull(firstVuln.getSeverity(), "CVE severity should not be null");
        assertNotNull(firstVuln.getDescription(), "CVE description should not be null");
        
        System.out.println("Successfully downloaded " + vulnerabilities.size() + " CVEs");
        System.out.println("Sample CVE: " + firstVuln.getId() + " - " + firstVuln.getTitle());
    }
    
    @Test
    @Order(3)
    @DisplayName("GHSA source should download GitHub Security Advisories")
    @Timeout(value = 5, unit = TimeUnit.MINUTES)
    void testGHSASourceDownload() {
        if (!ghsaSource.isEnabled()) {
            System.out.println("GHSA source is disabled, skipping test");
            return;
        }
        
        List<Vulnerability> vulnerabilities = ghsaSource.fetchVulnerabilities()
            .await().atMost(TIMEOUT);
        
        assertNotNull(vulnerabilities);
        assertFalse(vulnerabilities.isEmpty(), "GHSA source should return vulnerabilities");
        
        // Verify GHSA data structure
        Vulnerability firstVuln = vulnerabilities.get(0);
        assertNotNull(firstVuln.getId(), "GHSA ID should not be null");
        assertTrue(firstVuln.getId().startsWith("GHSA-"), "GHSA ID should start with GHSA-");
        assertNotNull(firstVuln.getTitle(), "GHSA title should not be null");
        assertNotNull(firstVuln.getSeverity(), "GHSA severity should not be null");
        
        System.out.println("Successfully downloaded " + vulnerabilities.size() + " GHSAs");
        System.out.println("Sample GHSA: " + firstVuln.getId() + " - " + firstVuln.getTitle());
    }
    
    @Test
    @Order(4)
    @DisplayName("OSV source should download Open Source Vulnerabilities")
    @Timeout(value = 5, unit = TimeUnit.MINUTES)
    void testOSVSourceDownload() {
        if (!osvSource.isEnabled()) {
            System.out.println("OSV source is disabled, skipping test");
            return;
        }
        
        List<Vulnerability> vulnerabilities = osvSource.fetchVulnerabilities()
            .await().atMost(TIMEOUT);
        
        assertNotNull(vulnerabilities);
        assertFalse(vulnerabilities.isEmpty(), "OSV source should return vulnerabilities");
        
        // Verify OSV data structure
        Vulnerability firstVuln = vulnerabilities.get(0);
        assertNotNull(firstVuln.getId(), "OSV ID should not be null");
        assertNotNull(firstVuln.getTitle(), "OSV title should not be null");
        assertNotNull(firstVuln.getSeverity(), "OSV severity should not be null");
        
        // OSV should have ecosystem information
        assertTrue(firstVuln.getAffectedPackages() != null || 
                  firstVuln.getDescription().contains("ecosystem"),
                  "OSV should contain ecosystem information");
        
        System.out.println("Successfully downloaded " + vulnerabilities.size() + " OSV entries");
        System.out.println("Sample OSV: " + firstVuln.getId() + " - " + firstVuln.getTitle());
    }
    
    @Test
    @Order(5)
    @DisplayName("Should download vulnerabilities from multiple sources concurrently")
    @Timeout(value = 5, unit = TimeUnit.MINUTES)
    void testConcurrentMultiSourceDownload() throws InterruptedException {
        List<VulnerabilitySource> enabledSources = vulnerabilitySources.stream()
            .filter(VulnerabilitySource::isEnabled)
            .collect(Collectors.toList());
        
        if (enabledSources.isEmpty()) {
            System.out.println("No sources enabled, skipping concurrent test");
            return;
        }
        
        CountDownLatch latch = new CountDownLatch(enabledSources.size());
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger totalVulnerabilities = new AtomicInteger(0);
        
        // Start concurrent downloads
        long startTime = System.currentTimeMillis();
        
        for (VulnerabilitySource source : enabledSources) {
            CompletableFuture.runAsync(() -> {
                try {
                    System.out.println("Starting download from " + source.getSourceName());
                    List<Vulnerability> vulns = source.fetchVulnerabilities()
                        .await().atMost(TIMEOUT);
                    
                    if (vulns != null && !vulns.isEmpty()) {
                        successCount.incrementAndGet();
                        totalVulnerabilities.addAndGet(vulns.size());
                        System.out.println("Downloaded " + vulns.size() + 
                            " vulnerabilities from " + source.getSourceName());
                    }
                } catch (Exception e) {
                    System.err.println("Error downloading from " + 
                        source.getSourceName() + ": " + e.getMessage());
                } finally {
                    latch.countDown();
                }
            });
        }
        
        // Wait for all downloads to complete
        assertTrue(latch.await(5, TimeUnit.MINUTES), 
            "All sources should complete within 5 minutes");
        
        long duration = System.currentTimeMillis() - startTime;
        
        // Verify results
        assertTrue(successCount.get() > 0, 
            "At least one source should successfully download vulnerabilities");
        assertTrue(totalVulnerabilities.get() > 0, 
            "Should download at least some vulnerabilities");
        
        System.out.println("\nConcurrent download summary:");
        System.out.println("- Sources attempted: " + enabledSources.size());
        System.out.println("- Sources succeeded: " + successCount.get());
        System.out.println("- Total vulnerabilities: " + totalVulnerabilities.get());
        System.out.println("- Duration: " + duration + "ms");
    }
    
    @ParameterizedTest
    @Order(6)
    @ValueSource(strings = {"CVE", "GHSA", "OSV"})
    @DisplayName("Each source should handle pagination correctly")
    void testSourcePagination(String sourceName) {
        VulnerabilitySource source = vulnerabilitySources.stream()
            .filter(s -> s.getSourceName().equals(sourceName))
            .findFirst()
            .orElse(null);
        
        if (source == null || !source.isEnabled()) {
            System.out.println(sourceName + " source not available or disabled, skipping");
            return;
        }
        
        // Test pagination by fetching limited results
        List<Vulnerability> firstPage = source.fetchVulnerabilities()
            .await().atMost(TIMEOUT);
        
        assertNotNull(firstPage);
        assertTrue(firstPage.size() > 0, sourceName + " should return at least one vulnerability");
        
        // Verify IDs are unique
        long uniqueIds = firstPage.stream()
            .map(Vulnerability::getId)
            .distinct()
            .count();
        
        assertEquals(firstPage.size(), uniqueIds, 
            "All vulnerability IDs should be unique in " + sourceName);
    }
    
    @Test
    @Order(7)
    @DisplayName("Should handle source failures gracefully")
    void testSourceFailureHandling() {
        // Create a mock source that always fails
        VulnerabilitySource failingSource = new VulnerabilitySource() {
            @Override
            public Uni<List<Vulnerability>> fetchVulnerabilities() {
                return Uni.createFrom().failure(
                    new RuntimeException("Simulated source failure")
                );
            }
            
            @Override
            public boolean isEnabled() {
                return true;
            }
            
            @Override
            public String getSourceName() {
                return "FailingSource";
            }
        };
        
        // Should not throw, but return failure
        assertThrows(RuntimeException.class, () -> 
            failingSource.fetchVulnerabilities()
                .await().atMost(Duration.ofSeconds(10))
        );
    }
    
    @Test
    @Order(8)
    @DisplayName("Should validate vulnerability data completeness")
    void testVulnerabilityDataCompleteness() {
        List<VulnerabilitySource> enabledSources = vulnerabilitySources.stream()
            .filter(VulnerabilitySource::isEnabled)
            .limit(2) // Test first 2 enabled sources
            .collect(Collectors.toList());
        
        for (VulnerabilitySource source : enabledSources) {
            List<Vulnerability> vulns = source.fetchVulnerabilities()
                .await().atMost(TIMEOUT);
            
            if (vulns != null && !vulns.isEmpty()) {
                // Take first 10 vulnerabilities for validation
                vulns.stream().limit(10).forEach(vuln -> {
                    assertNotNull(vuln.getId(), 
                        source.getSourceName() + " vulnerability ID should not be null");
                    assertNotNull(vuln.getTitle(), 
                        source.getSourceName() + " vulnerability title should not be null");
                    assertNotNull(vuln.getSeverity(), 
                        source.getSourceName() + " vulnerability severity should not be null");
                    assertNotNull(vuln.getDescription(), 
                        source.getSourceName() + " vulnerability description should not be null");
                    assertNotNull(vuln.getPublishedDate(), 
                        source.getSourceName() + " vulnerability published date should not be null");
                    
                    // Severity should be valid
                    assertTrue(
                        List.of("LOW", "MEDIUM", "HIGH", "CRITICAL").contains(vuln.getSeverity()),
                        "Severity should be valid: " + vuln.getSeverity()
                    );
                });
            }
        }
    }
    
    @Test
    @Order(9)
    @DisplayName("Should cache vulnerability data appropriately")
    void testVulnerabilityCaching() {
        if (!cveSource.isEnabled()) {
            System.out.println("CVE source disabled, skipping cache test");
            return;
        }
        
        // First fetch
        long startTime1 = System.currentTimeMillis();
        List<Vulnerability> firstFetch = cveSource.fetchVulnerabilities()
            .await().atMost(TIMEOUT);
        long duration1 = System.currentTimeMillis() - startTime1;
        
        // Second fetch (should be cached)
        long startTime2 = System.currentTimeMillis();
        List<Vulnerability> secondFetch = cveSource.fetchVulnerabilities()
            .await().atMost(TIMEOUT);
        long duration2 = System.currentTimeMillis() - startTime2;
        
        // Verify same data
        assertEquals(firstFetch.size(), secondFetch.size(), 
            "Cached fetch should return same number of vulnerabilities");
        
        // Second fetch should be significantly faster due to caching
        assertTrue(duration2 < duration1 / 2, 
            "Cached fetch should be at least 2x faster");
        
        System.out.println("First fetch: " + duration1 + "ms");
        System.out.println("Cached fetch: " + duration2 + "ms");
        System.out.println("Cache speedup: " + (duration1 / duration2) + "x");
    }
    
    @Test
    @Order(10)
    @DisplayName("Should handle API rate limiting appropriately")
    void testRateLimitHandling() {
        // This test simulates rapid API calls to test rate limit handling
        if (!ghsaSource.isEnabled()) {
            System.out.println("GHSA source disabled, skipping rate limit test");
            return;
        }
        
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger rateLimitCount = new AtomicInteger(0);
        
        // Make 5 rapid requests
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (int i = 0; i < 5; i++) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    ghsaSource.fetchVulnerabilities()
                        .await().atMost(Duration.ofSeconds(30));
                    successCount.incrementAndGet();
                } catch (Exception e) {
                    if (e.getMessage() != null && 
                        (e.getMessage().contains("rate limit") || 
                         e.getMessage().contains("429"))) {
                        rateLimitCount.incrementAndGet();
                    }
                }
            });
            futures.add(future);
        }
        
        // Wait for all requests
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .join();
        
        // Should handle rate limits gracefully
        assertTrue(successCount.get() > 0 || rateLimitCount.get() > 0,
            "Should either succeed or hit rate limit");
        
        System.out.println("Successful requests: " + successCount.get());
        System.out.println("Rate limited requests: " + rateLimitCount.get());
    }
    
    @Test
    @Order(11)
    @DisplayName("Should aggregate vulnerabilities from all enabled sources")
    void testAggregatedVulnerabilityFetch() {
        List<Vulnerability> allVulnerabilities = new ArrayList<>();
        
        for (VulnerabilitySource source : vulnerabilitySources) {
            if (source.isEnabled()) {
                try {
                    List<Vulnerability> sourceVulns = source.fetchVulnerabilities()
                        .await().atMost(Duration.ofMinutes(2));
                    
                    if (sourceVulns != null) {
                        allVulnerabilities.addAll(sourceVulns);
                        System.out.println("Added " + sourceVulns.size() + 
                            " vulnerabilities from " + source.getSourceName());
                    }
                } catch (Exception e) {
                    System.err.println("Failed to fetch from " + 
                        source.getSourceName() + ": " + e.getMessage());
                }
            }
        }
        
        assertTrue(allVulnerabilities.size() > 0, 
            "Should aggregate at least some vulnerabilities");
        
        // Check for duplicates across sources
        long uniqueIds = allVulnerabilities.stream()
            .map(Vulnerability::getId)
            .distinct()
            .count();
        
        System.out.println("\nAggregation summary:");
        System.out.println("- Total vulnerabilities: " + allVulnerabilities.size());
        System.out.println("- Unique vulnerabilities: " + uniqueIds);
        System.out.println("- Duplicates: " + (allVulnerabilities.size() - uniqueIds));
    }
}