package ai.intelliswarm.vulnpatcher.services;

import ai.intelliswarm.vulnpatcher.core.StreamingCodeAnalyzer;
import ai.intelliswarm.vulnpatcher.git.GitRepositoryScanner;
import ai.intelliswarm.vulnpatcher.git.providers.GitProvider;
import ai.intelliswarm.vulnpatcher.matchers.VulnerabilityMatcher;
import ai.intelliswarm.vulnpatcher.models.FileMetadata;
import ai.intelliswarm.vulnpatcher.models.ScanResult;
import ai.intelliswarm.vulnpatcher.models.Vulnerability;
import ai.intelliswarm.vulnpatcher.sources.VulnerabilitySource;
import io.quarkus.test.InjectMock;
import io.quarkus.test.junit.QuarkusTest;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.inject.Instance;
import jakarta.inject.Inject;
import org.eclipse.jgit.api.Git;
import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.ArgumentCaptor;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@QuarkusTest
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class VulnerabilityDetectionServiceTest {
    
    @Inject
    VulnerabilityDetectionService detectionService;
    
    @InjectMock
    GitRepositoryScanner gitScanner;
    
    @InjectMock
    StreamingCodeAnalyzer codeAnalyzer;
    
    @InjectMock
    VulnerabilityMatcher vulnerabilityMatcher;
    
    @InjectMock
    Instance<VulnerabilitySource> vulnerabilitySources;
    
    @InjectMock
    Instance<GitProvider> gitProviders;
    
    private VulnerabilityDetectionService.ScanRequest testRequest;
    private List<Vulnerability> testVulnerabilities;
    private Path tempRepoPath;
    
    @BeforeEach
    void setUp() throws IOException {
        // Create test request
        testRequest = new VulnerabilityDetectionService.ScanRequest();
        testRequest.setRepositoryUrl("https://github.com/test/repo");
        testRequest.setBranch("main");
        testRequest.setCredentials(Map.of("token", "test-token"));
        testRequest.setLanguages(Arrays.asList("java", "python"));
        testRequest.setSeverityThreshold("MEDIUM");
        
        // Create test vulnerabilities
        testVulnerabilities = createTestVulnerabilities();
        
        // Create temp directory for repo
        tempRepoPath = Files.createTempDirectory("test-repo");
        
        // Mock vulnerability sources
        VulnerabilitySource mockSource = mock(VulnerabilitySource.class);
        when(mockSource.isEnabled()).thenReturn(true);
        when(mockSource.fetchVulnerabilities())
            .thenReturn(CompletableFuture.completedFuture(testVulnerabilities));
        when(vulnerabilitySources.stream()).thenReturn(Stream.of(mockSource));
    }
    
    @AfterEach
    void tearDown() throws IOException {
        if (tempRepoPath != null) {
            Files.walk(tempRepoPath)
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(File::delete);
        }
    }
    
    @Test
    @Order(1)
    @DisplayName("Should perform complete repository scan successfully")
    void testCompleteRepositoryScan() throws Exception {
        // Mock git operations
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        // Mock file analysis
        List<FileMetadata> mockFiles = createMockFileMetadata();
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(Multi.createFrom().items(mockFiles.stream()));
        
        // Mock vulnerability matching
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenAnswer(invocation -> {
                FileMetadata file = invocation.getArgument(0);
                if (file.getFilePath().contains("vulnerable")) {
                    ScanResult.VulnerabilityMatch match = new ScanResult.VulnerabilityMatch();
                    match.setVulnerability(testVulnerabilities.get(0));
                    match.setFilePath(file.getFilePath());
                    match.setLineNumber(10);
                    match.setAffectedCode("vulnerable code");
                    match.setConfidence(0.9);
                    return Arrays.asList(match);
                }
                return Collections.emptyList();
            });
        
        // Execute scan
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(30, TimeUnit.SECONDS);
        
        // Assertions
        assertNotNull(result);
        assertNotNull(result.getScanId());
        assertEquals(testRequest.getRepositoryUrl(), result.getRepositoryUrl());
        assertEquals(testRequest.getBranch(), result.getBranch());
        assertFalse(result.getVulnerabilities().isEmpty());
        assertTrue(result.getScanDuration() > 0);
        assertNotNull(result.getScanStartTime());
        assertNotNull(result.getScanEndTime());
        assertEquals("completed", result.getStatus());
        
        // Verify interactions
        verify(gitScanner).cloneRepository(eq(testRequest.getRepositoryUrl()), 
            any(Path.class), eq(testRequest.getBranch()), eq(testRequest.getCredentials()));
        verify(codeAnalyzer).analyzeRepository(any(Path.class), eq(testRequest.getLanguages()));
        verify(vulnerabilityMatcher, atLeastOnce()).findMatches(any(FileMetadata.class), anyList());
    }
    
    @Test
    @Order(2)
    @DisplayName("Should handle repository clone failure")
    void testRepositoryCloneFailure() {
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenThrow(new RuntimeException("Failed to clone repository"));
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        
        assertThrows(ExecutionException.class, () -> future.get(5, TimeUnit.SECONDS));
        
        // Verify error was from clone operation
        try {
            future.get();
        } catch (ExecutionException e) {
            assertTrue(e.getCause().getMessage().contains("Failed to clone"));
        } catch (InterruptedException e) {
            fail("Unexpected interruption");
        }
    }
    
    @ParameterizedTest
    @Order(3)
    @ValueSource(strings = {"LOW", "MEDIUM", "HIGH", "CRITICAL"})
    @DisplayName("Should filter vulnerabilities by severity threshold")
    void testSeverityFiltering(String threshold) throws Exception {
        testRequest.setSeverityThreshold(threshold);
        
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        FileMetadata mockFile = new FileMetadata();
        mockFile.setFilePath("/test.java");
        mockFile.setLanguage("java");
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(Multi.createFrom().item(mockFile));
        
        // Return vulnerabilities of all severities
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenReturn(createMatchesWithVariousSeverities());
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(10, TimeUnit.SECONDS);
        
        // Verify only vulnerabilities at or above threshold are included
        assertTrue(result.getVulnerabilities().stream()
            .allMatch(match -> {
                int vulnSeverity = getSeverityLevel(match.getVulnerability().getSeverity());
                int thresholdLevel = getSeverityLevel(threshold);
                return vulnSeverity >= thresholdLevel;
            }));
    }
    
    @Test
    @Order(4)
    @DisplayName("Should handle concurrent file analysis")
    void testConcurrentFileAnalysis() throws Exception {
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        // Create many files for concurrent processing
        int fileCount = 100;
        List<FileMetadata> files = IntStream.range(0, fileCount)
            .mapToObj(i -> {
                FileMetadata file = new FileMetadata();
                file.setFilePath("/file" + i + ".java");
                file.setLanguage("java");
                file.setContent("public class File" + i + " { }");
                return file;
            })
            .collect(Collectors.toList());
        
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(Multi.createFrom().items(files.stream()));
        
        // Track concurrent matcher calls
        ConcurrentHashMap<String, Integer> matcherCalls = new ConcurrentHashMap<>();
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenAnswer(invocation -> {
                FileMetadata file = invocation.getArgument(0);
                matcherCalls.compute(file.getFilePath(), (k, v) -> v == null ? 1 : v + 1);
                
                // Simulate some processing time
                Thread.sleep(10);
                
                return Collections.emptyList();
            });
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(30, TimeUnit.SECONDS);
        
        // Verify all files were processed
        assertEquals(fileCount, matcherCalls.size());
        assertTrue(matcherCalls.values().stream().allMatch(count -> count == 1));
    }
    
    @Test
    @Order(5)
    @DisplayName("Should track scan progress accurately")
    void testScanProgressTracking() throws Exception {
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        // Create files with delay to track progress
        List<FileMetadata> files = Arrays.asList(
            createFileMetadata("/file1.java", "java"),
            createFileMetadata("/file2.java", "java"),
            createFileMetadata("/file3.java", "java")
        );
        
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(Multi.createFrom().items(files.stream())
                .onItem().call(() -> Uni.createFrom().nullItem().onItem().delayIt().by(Duration.ofMillis(100))));
        
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenReturn(Collections.emptyList());
        
        // Track progress updates
        List<Double> progressUpdates = Collections.synchronizedList(new ArrayList<>());
        
        // Execute scan
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(10, TimeUnit.SECONDS);
        
        assertNotNull(result);
        assertEquals(files.size(), result.getFilesScanned());
    }
    
    @ParameterizedTest
    @Order(6)
    @MethodSource("provideLanguageCombinations")
    @DisplayName("Should scan only specified languages")
    void testLanguageFiltering(List<String> languages, int expectedFileCount) throws Exception {
        testRequest.setLanguages(languages);
        
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        // Create files of different languages
        List<FileMetadata> allFiles = Arrays.asList(
            createFileMetadata("/test.java", "java"),
            createFileMetadata("/test.py", "python"),
            createFileMetadata("/test.js", "javascript"),
            createFileMetadata("/test.cpp", "c++"),
            createFileMetadata("/test.kt", "kotlin")
        );
        
        when(codeAnalyzer.analyzeRepository(any(Path.class), eq(languages)))
            .thenReturn(Multi.createFrom().items(allFiles.stream()
                .filter(f -> languages.contains(f.getLanguage()))));
        
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenReturn(Collections.emptyList());
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(10, TimeUnit.SECONDS);
        
        assertEquals(expectedFileCount, result.getFilesScanned());
    }
    
    @Test
    @Order(7)
    @DisplayName("Should handle large repositories efficiently")
    @Timeout(value = 60, unit = TimeUnit.SECONDS)
    void testLargeRepositoryPerformance() throws Exception {
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        // Simulate large repository
        int fileCount = 10000;
        Multi<FileMetadata> fileStream = Multi.createFrom().emitter(emitter -> {
            for (int i = 0; i < fileCount; i++) {
                FileMetadata file = createFileMetadata("/path/to/file" + i + ".java", "java");
                emitter.emit(file);
            }
            emitter.complete();
        });
        
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(fileStream);
        
        // Fast vulnerability matching
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenReturn(Collections.emptyList());
        
        long startTime = System.currentTimeMillis();
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(60, TimeUnit.SECONDS);
        
        long duration = System.currentTimeMillis() - startTime;
        
        assertNotNull(result);
        assertEquals(fileCount, result.getFilesScanned());
        
        // Performance assertion
        double filesPerSecond = (double) fileCount / (duration / 1000.0);
        System.out.println("Scanned " + fileCount + " files in " + duration + "ms (" + filesPerSecond + " files/sec)");
        assertTrue(filesPerSecond > 100, "Should scan at least 100 files per second");
    }
    
    @Test
    @Order(8)
    @DisplayName("Should deduplicate vulnerability matches")
    void testVulnerabilityDeduplication() throws Exception {
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        FileMetadata file1 = createFileMetadata("/file1.java", "java");
        FileMetadata file2 = createFileMetadata("/file2.java", "java");
        
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(Multi.createFrom().items(file1, file2));
        
        // Return same vulnerability for both files
        ScanResult.VulnerabilityMatch match1 = createVulnerabilityMatch(testVulnerabilities.get(0), "/file1.java", 10);
        ScanResult.VulnerabilityMatch match2 = createVulnerabilityMatch(testVulnerabilities.get(0), "/file2.java", 20);
        
        when(vulnerabilityMatcher.findMatches(eq(file1), anyList()))
            .thenReturn(Arrays.asList(match1));
        when(vulnerabilityMatcher.findMatches(eq(file2), anyList()))
            .thenReturn(Arrays.asList(match2));
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(10, TimeUnit.SECONDS);
        
        // Should have both matches (different files)
        assertEquals(2, result.getVulnerabilities().size());
        
        // But should track unique vulnerability count
        long uniqueVulnerabilities = result.getVulnerabilities().stream()
            .map(m -> m.getVulnerability().getId())
            .distinct()
            .count();
        assertEquals(1, uniqueVulnerabilities);
    }
    
    @Test
    @Order(9)
    @DisplayName("Should handle scan cancellation")
    void testScanCancellation() throws Exception {
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        // Create slow stream to allow cancellation
        Multi<FileMetadata> slowStream = Multi.createFrom().emitter(emitter -> {
            for (int i = 0; i < 1000; i++) {
                if (Thread.currentThread().isInterrupted()) {
                    emitter.complete();
                    return;
                }
                
                emitter.emit(createFileMetadata("/file" + i + ".java", "java"));
                
                try {
                    Thread.sleep(10); // Slow emission
                } catch (InterruptedException e) {
                    emitter.complete();
                    return;
                }
            }
            emitter.complete();
        });
        
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(slowStream);
        
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenReturn(Collections.emptyList());
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        
        // Cancel after short delay
        Thread.sleep(100);
        assertTrue(future.cancel(true));
        
        assertTrue(future.isCancelled());
    }
    
    @Test
    @Order(10)
    @DisplayName("Should cache vulnerability database during scan")
    void testVulnerabilityCaching() throws Exception {
        Git mockGit = mock(Git.class);
        when(gitScanner.cloneRepository(anyString(), any(Path.class), anyString(), any()))
            .thenReturn(mockGit);
        
        // Multiple files to process
        List<FileMetadata> files = IntStream.range(0, 10)
            .mapToObj(i -> createFileMetadata("/file" + i + ".java", "java"))
            .collect(Collectors.toList());
        
        when(codeAnalyzer.analyzeRepository(any(Path.class), anyList()))
            .thenReturn(Multi.createFrom().items(files.stream()));
        
        when(vulnerabilityMatcher.findMatches(any(FileMetadata.class), anyList()))
            .thenReturn(Collections.emptyList());
        
        CompletableFuture<ScanResult> future = detectionService.scanRepository(testRequest);
        ScanResult result = future.get(10, TimeUnit.SECONDS);
        
        // Verify vulnerability database was fetched only once
        verify(vulnerabilitySources, times(1)).stream();
    }
    
    // Helper methods
    
    private List<Vulnerability> createTestVulnerabilities() {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        String[] severities = {"LOW", "MEDIUM", "HIGH", "CRITICAL"};
        for (int i = 0; i < 4; i++) {
            Vulnerability vuln = new Vulnerability();
            vuln.setId("CVE-2023-" + String.format("%04d", i));
            vuln.setTitle("Test Vulnerability " + i);
            vuln.setSeverity(severities[i]);
            vuln.setDescription("Test description " + i);
            vuln.setAffectedLanguages(Arrays.asList("java", "python"));
            vulnerabilities.add(vuln);
        }
        
        return vulnerabilities;
    }
    
    private List<FileMetadata> createMockFileMetadata() {
        return Arrays.asList(
            createFileMetadata("/src/main/java/VulnerableService.java", "java"),
            createFileMetadata("/src/main/java/SafeService.java", "java"),
            createFileMetadata("/src/main/python/vulnerable_script.py", "python"),
            createFileMetadata("/src/test/java/TestService.java", "java")
        );
    }
    
    private FileMetadata createFileMetadata(String path, String language) {
        FileMetadata file = new FileMetadata();
        file.setFilePath(path);
        file.setLanguage(language);
        file.setContent("Sample content for " + path);
        file.setLineCount(100);
        return file;
    }
    
    private List<ScanResult.VulnerabilityMatch> createMatchesWithVariousSeverities() {
        return testVulnerabilities.stream()
            .map(vuln -> createVulnerabilityMatch(vuln, "/test.java", 10))
            .collect(Collectors.toList());
    }
    
    private ScanResult.VulnerabilityMatch createVulnerabilityMatch(
            Vulnerability vulnerability, String filePath, int lineNumber) {
        ScanResult.VulnerabilityMatch match = new ScanResult.VulnerabilityMatch();
        match.setVulnerability(vulnerability);
        match.setFilePath(filePath);
        match.setLineNumber(lineNumber);
        match.setAffectedCode("vulnerable code");
        match.setConfidence(0.9);
        return match;
    }
    
    private int getSeverityLevel(String severity) {
        return switch (severity) {
            case "LOW" -> 1;
            case "MEDIUM" -> 2;
            case "HIGH" -> 3;
            case "CRITICAL" -> 4;
            default -> 0;
        };
    }
    
    private static Stream<Arguments> provideLanguageCombinations() {
        return Stream.of(
            Arguments.of(Arrays.asList("java"), 1),
            Arguments.of(Arrays.asList("python"), 1),
            Arguments.of(Arrays.asList("java", "python"), 2),
            Arguments.of(Arrays.asList("javascript", "c++"), 2),
            Arguments.of(Arrays.asList("java", "python", "javascript", "c++", "kotlin"), 5)
        );
    }
}