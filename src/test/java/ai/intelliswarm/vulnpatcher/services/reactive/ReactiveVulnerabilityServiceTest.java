package ai.intelliswarm.vulnpatcher.services.reactive;

import ai.intelliswarm.vulnpatcher.config.MetricsConfig;
import ai.intelliswarm.vulnpatcher.models.Vulnerability;
import ai.intelliswarm.vulnpatcher.sources.VulnerabilitySource;
import io.quarkus.test.InjectMock;
import io.quarkus.test.junit.QuarkusTest;
import io.smallrye.mutiny.Multi;
import io.smallrye.mutiny.Uni;
import io.smallrye.mutiny.helpers.test.AssertSubscriber;
import io.smallrye.mutiny.helpers.test.UniAssertSubscriber;
import jakarta.enterprise.inject.Instance;
import jakarta.inject.Inject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;

import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@QuarkusTest
public class ReactiveVulnerabilityServiceTest {
    
    @Inject
    ReactiveVulnerabilityService service;
    
    @InjectMock
    Instance<VulnerabilitySource> vulnerabilitySources;
    
    @InjectMock
    MetricsConfig.MetricsService metricsService;
    
    @Mock
    VulnerabilitySource mockSource1;
    
    @Mock
    VulnerabilitySource mockSource2;
    
    private List<Vulnerability> testVulnerabilities;
    
    @BeforeEach
    void setUp() {
        // Create test vulnerabilities
        Vulnerability vuln1 = new Vulnerability();
        vuln1.setId("CVE-2023-0001");
        vuln1.setTitle("Test Vulnerability 1");
        vuln1.setSeverity("HIGH");
        vuln1.setDescription("Test description 1");
        vuln1.setAffectedLanguages(Arrays.asList("Java", "Python"));
        
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setId("CVE-2023-0002");
        vuln2.setTitle("Test Vulnerability 2");
        vuln2.setSeverity("CRITICAL");
        vuln2.setDescription("Test description 2");
        vuln2.setAffectedLanguages(Arrays.asList("JavaScript"));
        
        Vulnerability vuln3 = new Vulnerability();
        vuln3.setId("CVE-2023-0003");
        vuln3.setTitle("Test Vulnerability 3");
        vuln3.setSeverity("MEDIUM");
        vuln3.setDescription("Test description 3");
        vuln3.setAffectedLanguages(Arrays.asList("Java"));
        
        testVulnerabilities = Arrays.asList(vuln1, vuln2, vuln3);
        
        // Configure mock sources
        when(vulnerabilitySources.stream()).thenReturn(Stream.of(mockSource1, mockSource2));
        when(mockSource1.isEnabled()).thenReturn(true);
        when(mockSource2.isEnabled()).thenReturn(true);
        when(mockSource1.getSourceName()).thenReturn("MockSource1");
        when(mockSource2.getSourceName()).thenReturn("MockSource2");
    }
    
    @Test
    @DisplayName("Should fetch vulnerabilities from all enabled sources")
    void testFetchVulnerabilitiesStream() {
        // Mock source responses
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList(testVulnerabilities.get(0), testVulnerabilities.get(1))));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList(testVulnerabilities.get(2))));
        
        // Test stream
        Multi<Vulnerability> stream = service.fetchVulnerabilitiesStream();
        
        AssertSubscriber<Vulnerability> subscriber = stream
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertEquals(3, results.size());
        verify(metricsService, times(3)).incrementVulnerabilitiesDetected();
        verify(metricsService, times(2)).recordApiCallDuration(anyString(), anyLong());
    }
    
    @Test
    @DisplayName("Should handle source failures gracefully")
    void testFetchVulnerabilitiesWithSourceFailure() {
        // Mock one source failing
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().failure(new RuntimeException("Source error")));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList(testVulnerabilities.get(0))));
        
        // Test stream continues with working source
        Multi<Vulnerability> stream = service.fetchVulnerabilitiesStream();
        
        AssertSubscriber<Vulnerability> subscriber = stream
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertEquals(1, results.size());
        assertEquals("CVE-2023-0001", results.get(0).getId());
        verify(metricsService, times(1)).incrementApiCallErrors("MockSource1");
    }
    
    @Test
    @DisplayName("Should filter vulnerabilities by severity")
    void testFetchVulnerabilitiesBySeverity() {
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(testVulnerabilities));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Multi<Vulnerability> highSeverity = service.fetchVulnerabilitiesBySeverity("HIGH");
        
        AssertSubscriber<Vulnerability> subscriber = highSeverity
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertEquals(1, results.size());
        assertEquals("HIGH", results.get(0).getSeverity());
    }
    
    @Test
    @DisplayName("Should filter vulnerabilities by language")
    void testFetchVulnerabilitiesForLanguages() {
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(testVulnerabilities));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Multi<Vulnerability> javaVulns = service.fetchVulnerabilitiesForLanguages(Arrays.asList("Java"));
        
        AssertSubscriber<Vulnerability> subscriber = javaVulns
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertEquals(2, results.size());
        assertTrue(results.stream().allMatch(v -> 
            v.getAffectedLanguages() != null && v.getAffectedLanguages().contains("Java")));
    }
    
    @Test
    @DisplayName("Should fetch vulnerabilities in batches")
    void testFetchVulnerabilitiesInBatches() {
        // Create more vulnerabilities for batching
        java.util.List<Vulnerability> manyVulns = new java.util.ArrayList<>();
        for (int i = 0; i < 250; i++) {
            Vulnerability v = new Vulnerability();
            v.setId("CVE-2023-" + String.format("%04d", i));
            v.setSeverity("MEDIUM");
            manyVulns.add(v);
        }
        
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(manyVulns));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Multi<List<Vulnerability>> batches = service.fetchVulnerabilitiesInBatches();
        
        AssertSubscriber<List<Vulnerability>> subscriber = batches
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<List<Vulnerability>> results = subscriber.awaitCompletion().getItems();
        
        assertTrue(results.size() > 1);
        assertTrue(results.stream().allMatch(batch -> batch.size() <= 100));
        assertEquals(250, results.stream().mapToInt(List::size).sum());
    }
    
    @Test
    @DisplayName("Should search vulnerabilities by keyword")
    void testSearchVulnerabilities() {
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(testVulnerabilities));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Multi<Vulnerability> searchResults = service.searchVulnerabilities("0001");
        
        AssertSubscriber<Vulnerability> subscriber = searchResults
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertEquals(1, results.size());
        assertEquals("CVE-2023-0001", results.get(0).getId());
    }
    
    @Test
    @DisplayName("Should calculate vulnerability statistics correctly")
    void testGetVulnerabilityStats() {
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(testVulnerabilities));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Uni<ReactiveVulnerabilityService.VulnerabilityStats> statsUni = service.getVulnerabilityStats();
        
        UniAssertSubscriber<ReactiveVulnerabilityService.VulnerabilityStats> subscriber = statsUni
            .subscribe().withSubscriber(UniAssertSubscriber.create());
        
        ReactiveVulnerabilityService.VulnerabilityStats stats = subscriber.awaitItem().getItem();
        
        assertNotNull(stats);
        assertEquals(3, stats.total);
        assertEquals(1, stats.critical);
        assertEquals(1, stats.high);
        assertEquals(1, stats.medium);
        assertEquals(0, stats.low);
        
        // Test percentage calculations
        assertEquals(33.33, stats.getCriticalPercentage(), 0.01);
        assertEquals(33.33, stats.getHighPercentage(), 0.01);
        assertEquals(33.33, stats.getMediumPercentage(), 0.01);
        assertEquals(0.0, stats.getLowPercentage(), 0.01);
    }
    
    @Test
    @DisplayName("Should handle empty results correctly")
    void testEmptyResults() {
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Multi<Vulnerability> stream = service.fetchVulnerabilitiesStream();
        
        AssertSubscriber<Vulnerability> subscriber = stream
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertTrue(results.isEmpty());
        verify(metricsService, never()).incrementVulnerabilitiesDetected();
    }
    
    @Test
    @DisplayName("Should respect timeout when fetching all vulnerabilities")
    void testFetchAllVulnerabilitiesTimeout() {
        // Mock slow source
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(() -> {
                try {
                    Thread.sleep(Duration.ofMinutes(15).toMillis());
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return Arrays.asList();
            }));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Uni<List<Vulnerability>> allVulns = service.fetchAllVulnerabilities();
        
        UniAssertSubscriber<List<Vulnerability>> subscriber = allVulns
            .subscribe().withSubscriber(UniAssertSubscriber.create());
        
        subscriber.awaitFailure();
        assertNotNull(subscriber.getFailure());
        assertTrue(subscriber.getFailure().getMessage().contains("Timeout"));
    }
    
    @Test
    @DisplayName("Should handle disabled sources correctly")
    void testDisabledSources() {
        when(mockSource1.isEnabled()).thenReturn(false);
        when(mockSource2.isEnabled()).thenReturn(true);
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList(testVulnerabilities.get(0))));
        
        Multi<Vulnerability> stream = service.fetchVulnerabilitiesStream();
        
        AssertSubscriber<Vulnerability> subscriber = stream
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertEquals(1, results.size());
        verify(mockSource1, never()).fetchVulnerabilities();
        verify(mockSource2, times(1)).fetchVulnerabilities();
    }
    
    @Test
    @DisplayName("Should handle concurrent access correctly")
    void testConcurrentAccess() throws InterruptedException {
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList(testVulnerabilities.get(0))));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList(testVulnerabilities.get(1))));
        
        java.util.List<Thread> threads = new java.util.ArrayList<>();
        java.util.List<java.util.List<Vulnerability>> results = java.util.Collections.synchronizedList(new java.util.ArrayList<>());
        
        for (int i = 0; i < 5; i++) {
            Thread thread = new Thread(() -> {
                List<Vulnerability> vulns = service.fetchVulnerabilitiesStream()
                    .collect().asList()
                    .await().indefinitely();
                results.add(vulns);
            });
            threads.add(thread);
            thread.start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        assertEquals(5, results.size());
        assertTrue(results.stream().allMatch(list -> list.size() == 2));
    }
    
    @Test
    @DisplayName("Should retry failed sources with backoff")
    void testRetryWithBackoff() {
        // Mock source that fails twice then succeeds
        when(mockSource1.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().failure(new RuntimeException("Error 1")))
            .thenReturn(Uni.createFrom().failure(new RuntimeException("Error 2")))
            .thenReturn(Uni.createFrom().item(Arrays.asList(testVulnerabilities.get(0))));
        when(mockSource2.fetchVulnerabilities())
            .thenReturn(Uni.createFrom().item(Arrays.asList()));
        
        Multi<Vulnerability> stream = service.fetchVulnerabilitiesStream();
        
        AssertSubscriber<Vulnerability> subscriber = stream
            .subscribe().withSubscriber(AssertSubscriber.create(10));
        
        List<Vulnerability> results = subscriber.awaitCompletion().getItems();
        
        assertEquals(1, results.size());
        verify(mockSource1, times(3)).fetchVulnerabilities();
    }
}